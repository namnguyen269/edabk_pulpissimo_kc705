
##source [find interface/ftdi/digilent-hs1.cfg]
# this supports JTAG-HS1 and JTAG-SMT1
# (the later being the OEM on-board version)

adapter driver ftdi
ftdi device_desc "Digilent Adept USB Device"
ftdi vid_pid 0x0403 0x6010
# channel 1 does not have any functionality
ftdi channel 0
# just TCK TDI TDO TMS, no reset
ftdi layout_init 0x0088 0x008b
reset_config none


##source [find cpld/xilinx-xc7.cfg]
# SPDX-License-Identifier: GPL-2.0-or-later

# xilinx series 7 (artix, kintex, virtex)
# http://www.xilinx.com/support/documentation/user_guides/ug470_7Series_Config.pdf

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME xc7
}

# the 4 top bits (28:31) are the die stepping/revisions. ignore it.
jtag newtap $_CHIPNAME tap -irlen 6 -ignore-version \
	-expected-id 0x03622093 \
	-expected-id 0x03620093 \
	-expected-id 0x037C4093 \
	-expected-id 0x0362F093 \
	-expected-id 0x037C8093 \
	-expected-id 0x037C7093 \
	-expected-id 0x037C3093 \
	-expected-id 0x0362E093 \
	-expected-id 0x037C2093 \
	-expected-id 0x0362D093 \
	-expected-id 0x0362C093 \
	-expected-id 0x03632093 \
	-expected-id 0x03631093 \
	-expected-id 0x03636093 \
	-expected-id 0x03647093 \
	-expected-id 0x0364C093 \
	-expected-id 0x03651093 \
	-expected-id 0x03747093 \
	-expected-id 0x03656093 \
	-expected-id 0x03752093 \
	-expected-id 0x03751093 \
	-expected-id 0x03671093 \
	-expected-id 0x036B3093 \
	-expected-id 0x036B7093 \
	-expected-id 0x036BB093 \
	-expected-id 0x036BF093 \
	-expected-id 0x03667093 \
	-expected-id 0x03682093 \
	-expected-id 0x03687093 \
	-expected-id 0x03692093 \
	-expected-id 0x03691093 \
	-expected-id 0x03696093 \
	-expected-id 0x036D5093 \
	-expected-id 0x036D9093 \
	-expected-id 0x036DB093

pld device virtex2 $_CHIPNAME.tap 1

set XC7_JSHUTDOWN 0x0d
set XC7_JPROGRAM 0x0b
set XC7_JSTART 0x0c
set XC7_BYPASS 0x3f

proc xc7_program {tap} {
	global XC7_JSHUTDOWN XC7_JPROGRAM XC7_JSTART XC7_BYPASS
	irscan $tap $XC7_JSHUTDOWN
	irscan $tap $XC7_JPROGRAM
	runtest 60000
	#JSTART prevents this from working...
	#irscan $tap $XC7_JSTART
	runtest 2000
	irscan $tap $XC7_BYPASS
	runtest 2000
}

##source [find cpld/jtagspi.cfg]
# SPDX-License-Identifier: GPL-2.0-or-later

set _USER1 0x02

if { [info exists JTAGSPI_IR] } {
	set _JTAGSPI_IR $JTAGSPI_IR
} else {
	set _JTAGSPI_IR $_USER1
}

if { [info exists TARGETNAME] } {
	set _TARGETNAME $TARGETNAME
} else {
	set _TARGETNAME $_CHIPNAME.proxy
}

if { [info exists FLASHNAME] } {
	set _FLASHNAME $FLASHNAME
} else {
	set _FLASHNAME $_CHIPNAME.spi
}

target create $_TARGETNAME testee -chain-position $_CHIPNAME.tap
flash bank $_FLASHNAME jtagspi 0 0 0 0 $_TARGETNAME $_JTAGSPI_IR

proc jtagspi_init {chain_id proxy_bit} {
	# load proxy bitstream $proxy_bit and probe spi flash
	global _FLASHNAME
	pld load $chain_id $proxy_bit
	reset halt
	flash probe $_FLASHNAME
}

proc jtagspi_program {bin addr} {
	# write and verify binary file $bin at offset $addr
	global _FLASHNAME
	flash write_image erase $bin $addr
	flash verify_bank $_FLASHNAME $bin $addr
}


##source [find fpga/xilinx-xadc.cfg]
# SPDX-License-Identifier: GPL-2.0-or-later

# Xilinx XADC support for 7 Series FPGAs
#
# The 7 Series FPGAs contain an on-chip 12 bit ADC that can probe die
# temperature, internal power supply rail voltages as well as external
# voltages. The XADC is available both from fabric as well as through the
# JTAG TAP.
#
# This code implements access through the JTAG TAP.
#
# https://www.xilinx.com/support/documentation/user_guides/ug480_7Series_XADC.pdf

# build a 32 bit DRP command for the XADC DR
proc xadc_cmd {cmd addr data} {
	array set cmds {
		NOP 0x00
		READ 0x01
		WRITE 0x02
	}
	return [expr {($cmds($cmd) << 26) | ($addr << 16) | ($data << 0)}]
}

# XADC register addresses
# Some addresses (status registers 0-3) have special function when written to.
proc XADC {key} {
	array set addrs {
		TEMP 0x00
		LOCK 0x00
		VCCINT 0x01
		VCCAUX 0x02
		VAUXEN 0x02
		VPVN 0x03
		RESET 0x03
		VREFP 0x04
		VREFN 0x05
		VCCBRAM 0x06
		SUPAOFFS 0x08
		ADCAOFFS 0x09
		ADCAGAIN 0x0a
		VCCPINT 0x0d
		VCCPAUX 0x0e
		VCCODDR 0x0f
		VAUX0 0x10
		VAUX1 0x11
		VAUX2 0x12
		VAUX3 0x13
		VAUX4 0x14
		VAUX5 0x15
		VAUX6 0x16
		VAUX7 0x17
		VAUX8 0x18
		VAUX9 0x19
		VAUX10 0x1a
		VAUX11 0x1b
		VAUX12 0x1c
		VAUX13 0x1d
		VAUX14 0x1e
		VAUX15 0x1f
		SUPBOFFS 0x30
		ADCBOFFS 0x31
		ADCBGAIN 0x32
		FLAG 0x3f
		CFG0 0x40
		CFG1 0x41
		CFG2 0x42
		SEQ0 0x48
		SEQ1 0x49
		SEQ2 0x4a
		SEQ3 0x4b
		SEQ4 0x4c
		SEQ5 0x4d
		SEQ6 0x4e
		SEQ7 0x4f
		ALARM0 0x50
		ALARM1 0x51
		ALARM2 0x52
		ALARM3 0x53
		ALARM4 0x54
		ALARM5 0x55
		ALARM6 0x56
		ALARM7 0x57
		ALARM8 0x58
		ALARM9 0x59
		ALARM10 0x5a
		ALARM11 0x5b
		ALARM12 0x5c
		ALARM13 0x5d
		ALARM14 0x5e
		ALARM15 0x5f
	}
	return $addrs($key)
}

# Select the XADC DR
proc xadc_select {tap} {
	set XADC_IR 0x37
	irscan $tap $XADC_IR
	runtest 10
}

# XADC transfer
proc xadc_xfer {tap cmd addr data} {
	set ret [drscan $tap 32 [xadc_cmd $cmd $addr $data]]
	runtest 10
	return [expr "0x$ret"]
}

# XADC register write
proc xadc_write {tap addr data} {
	xadc_xfer $tap WRITE $addr $data
}

# XADC register read, non-pipelined
proc xadc_read {tap addr} {
	xadc_xfer $tap READ $addr 0
	return [xadc_xfer $tap NOP 0 0]
}

# convert 16 bit register code from ADC measurement on
# external voltages (VAUX) to Volt
proc xadc_volt {code} {
	return [expr {$code * 1./(1 << 16)}]
}

# convert 16 bit temperature measurement to Celsius
proc xadc_temp {code} {
	return [expr {$code * 503.975/(1 << 16) - 273.15}]
}

# convert 16 bit suppply voltage measurement to Volt
proc xadc_sup {code} {
	return [expr {$code * 3./(1 << 16)}]
}

# perform a single channel measurement using default settings
proc xadc_single {tap ch} {
	set cfg0 [xadc_read $tap [XADC CFG0]]
	set cfg1 [xadc_read $tap [XADC CFG1]]
	# set channel
	xadc_write $tap [XADC CFG0] $cfg0
	# single channel, disable the sequencer
	xadc_write $tap [XADC CFG1] 0x3000
	# leave some time for the conversion
	runtest 100
	set ret [xadc_read $tap [XADC $ch]]
	# restore CFG0/1
	xadc_write $tap [XADC CFG0] $cfg0
	xadc_write $tap [XADC CFG1] $cfg1
	return $ret
}

# measure all internal voltages
proc xadc_report {tap} {
	xadc_select $tap
	echo "TEMP [format %.2f [xadc_temp [xadc_single $tap TEMP]]] C"
	foreach ch [list VCCINT VCCAUX VCCBRAM VPVN VREFP VREFN \
		VCCPINT VCCPAUX VCCODDR] {
		echo "$ch [format %.3f [xadc_sup [xadc_single $tap $ch]]] V"
	}
}



##ource [find fpga/xilinx-dna.cfg]
proc xilinx_dna_addr {chip} {
	array set addrs {
		Spartan6 0x30
		Series7 0x17
	}
	return $addrs($chip)
}

# Get the "Device DNA".
# Most Xilinx FPGA devices contain an embedded, unique device identifier.
# The identifier is nonvolatile, permanently programmed into
# the FPGA, and is unchangeable providing a great serial / tracking number.
# This function returns the DNA as a 64 bit integer with the 7 LSBs zeroed.
# This is compatible with the FUSE DNA which contains all 64 bits.
proc xilinx_get_dna {tap chip} {
	set XC7_ISC_ENABLE 0x10
	set XC7_ISC_DISABLE 0x16
	set XC7_ISC_DNA [xilinx_dna_addr $chip]

	irscan $tap $XC7_ISC_ENABLE
	runtest 64
	irscan $tap $XC7_ISC_DNA
	scan [drscan $tap 32 0 32 0] "%08x %08x" hi lo
	runtest 64
	irscan $tap $XC7_ISC_DISABLE
	runtest 64
	# openocd interprets DR scans as LSB first, bit-reverse it
	return [scan [string reverse [format "%032b%032bb0" $lo $hi]] "%i"]
}

# Print out the "Device DNA" in the same format that impact uses.
proc xilinx_print_dna {dna} {
	set dna [expr {$dna >> 64 - 57}]
	echo [format "DNA = %057b (0x%016x)" $dna $dna]
}

proc xc7_get_dna {tap} {
	return [xilinx_get_dna $tap Series7]
}

proc xc6s_get_dna {tap} {
	return [xilinx_get_dna $tap Spartan6]
}

adapter speed 25000

# example command to write bitstream, soft-cpu bios and runtime:
# openocd -f board/kc705.cfg -c "init;\
# jtagspi_init 0 bscan_spi_xc7k325t.bit;\
# jtagspi_program bitstream-kc705.bin 0;\
# jtagspi_program bios.bin 0xaf0000;\
# jtagspi_program runtime.fbi 0xb00000;\
# xc7_program xc7.tap;\
# exit"




